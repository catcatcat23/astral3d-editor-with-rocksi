/**
 * @license
 * Copyright 2010-2022 fik.js Authors
 * SPDX-License-Identifier: MIT
 */
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).FIK={})}(this,(function(t){"use strict";const e=function(t){console.error(t)},s={PI:Math.PI,toRad:Math.PI/180,toDeg:180/Math.PI,pi90:.5*Math.PI,twoPI:2*Math.PI,findAngle:function(t,e){let s,n,i,o=t.end.minus(e.end).lengthSq(),a=t.end.minus(t.start).lengthSq();return n=(o+a-e.end.minus(t.start).lengthSq())/Math.sqrt(4*o*a),s=n<=-1?Math.PI:n>=1?0:Math.acos(n),i=t.end.x*e.end.y-t.end.y*e.end.x,i>=0?s:-s},clamp:function(t,e,s){return t=(t=t<e?e:t)>s?s:t},lerp:function(t,e,s){return(1-s)*t+s*e},rand:function(t,e){return t+Math.random()*(e-t)},randInt:function(t,e){return t+Math.floor(Math.random()*(e-t+1))},nearEquals:function(t,e,s){return Math.abs(t-e)<=s},perpendicular:function(t,e){return!!s.nearEquals(t.dot(e),0,.01)},genPerpendicularVectorQuick:function(t){let e=t.clone();return Math.abs(t.y)<.99?e.set(-t.z,0,t.x).normalize():e.set(0,t.z,-t.y).normalize()},genPerpendicularVectorFrisvad:function(t){let e=t.clone();if(t.z<-.9999999)return e.set(0,-1,0);let s=1/(1+t.z);return e.set(1-t.x*t.x*s,-t.x*t.y*s,-t.x).normalize()},nearEquals:(t,e,s)=>Math.abs(t-e)<=s,rotateXDegs:function(t,e){return t.clone().rotate(e*s.toRad,"X")},rotateYDegs:function(t,e){return t.clone().rotate(e*s.toRad,"Y")},rotateZDegs:function(t,e){return t.clone().rotate(e*s.toRad,"Z")},withinManhattanDistance:function(t,e,s){return!(Math.abs(e.x-t.x)>s)&&(!(Math.abs(e.y-t.y)>s)&&!(Math.abs(e.z-t.z)>s))},manhattanDistanceBetween:function(t,e){return Math.abs(e.x-t.x)+Math.abs(e.y-t.y)+Math.abs(e.z-t.z)},distanceBetween:function(t,e){let s=e.x-t.x,n=e.y-t.y,i=void 0!==t.z?e.z-t.z:0;return Math.sqrt(s*s+n*n+i*i)},unwrapDeg:t=>t-360*Math.floor((t+180)/360),unwrapRad:t=>t-2*Math.floor((t+Math.PI)/(2*Math.PI))*Math.PI,rotateDegs:function(t,e){return t.clone().rotate(e*s.toRad)},validateDirectionUV:function(t){t.length()<0&&e("vector direction unit vector cannot be zero.")},validateLength:function(t){t<0&&e("Length must be a greater than or equal to zero.")}};class n{constructor(t=0,e=0){this.isVector2=!0,this.x=t,this.y=e}set(t,e){return this.x=t||0,this.y=e||0,this}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){let e=this.x-t.x,s=this.y-t.y;return e*e+s*s}multiplyScalar(t){return this.x*=t,this.y*=t,this}divideScalar(t){return this.multiplyScalar(1/t)}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}normalize(){return this.divideScalar(this.length()||1)}normalised(){return new this.constructor(this.x,this.y).normalize()}lengthSq(){return this.x*this.x+this.y*this.y}add(t){return this.x+=t.x,this.y+=t.y,this}plus(t){return new this.constructor(this.x+t.x,this.y+t.y)}min(t){return this.x-=t.x,this.y-=t.y,this}minus(t){return new n(this.x-t.x,this.y-t.y)}divideBy(t){return new this.constructor(this.x,this.y).divideScalar(t)}dot(t,e){return this.x*t.x+this.y*t.y}negate(){return this.x=-this.x,this.y=-this.y,this}negated(){return new this.constructor(-this.x,-this.y)}clone(){return new this.constructor(this.x,this.y)}copy(t){return this.x=t.x,this.y=t.y,this}cross(t){return this.x*t.y-this.y*t.x}sign(t){return this.cross(t)>=0?1:-1}approximatelyEquals(t,e){if(e<0)return!1;let s=Math.abs(this.x-t.x),n=Math.abs(this.y-t.y);return s<e&&n<e}rotate(t){let e=Math.cos(t),s=Math.sin(t),n=this.x*e-this.y*s,i=this.x*s+this.y*e;return this.x=n,this.y=i,this}angleTo(t){let e=this.dot(t)/Math.sqrt(this.lengthSq()*t.lengthSq());return e<=-1?Math.PI:e>=1?0:Math.acos(e)}getSignedAngle(t){let e=this.angleTo(t);return 1===this.sign(t)?e:-e}constrainedUV(t,e,s){let n=t.getSignedAngle(this);return n>s&&this.copy(t).rotate(s),n<e&&this.copy(t).rotate(e),this}}class i{constructor(t=0,e=0,s=0){this.isVector3=!0,this.x=t,this.y=e,this.z=s}set(t,e,s){return this.x=t||0,this.y=e||0,this.z=s||0,this}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){let e=this.x-t.x,s=this.y-t.y,n=this.z-t.z;return e*e+s*s+n*n}abs(){return new this.constructor(this.x<0?-this.x:this.x,this.y<0?-this.y:this.y,this.z<0?-this.z:this.z)}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}normalize(){return this.divideScalar(this.length()||1)}normalised(){return new this.constructor(this.x,this.y,this.z).normalize()}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this}min(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this}plus(t){return new this.constructor(this.x+t.x,this.y+t.y,this.z+t.z)}minus(t){return new this.constructor(this.x-t.x,this.y-t.y,this.z-t.z)}divideBy(t){return new this.constructor(this.x/t,this.y/t,this.z/t)}multiply(t){return new this.constructor(this.x*t,this.y*t,this.z*t)}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}divideScalar(t){return this.multiplyScalar(1/t)}cross(t){return new this.constructor(this.y*t.z-this.z*t.y,this.z*t.x-this.x*t.z,this.x*t.y-this.y*t.x)}crossVectors(t,e){let s=t.x,n=t.y,i=t.z,o=e.x,a=e.y,h=e.z;return this.x=n*h-i*a,this.y=i*o-s*h,this.z=s*a-n*o,this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}negated(){return new i(-this.x,-this.y,-this.z)}clone(){return new i(this.x,this.y,this.z)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}approximatelyEquals(t,e){if(e<0)return!1;let s=Math.abs(this.x-t.x),n=Math.abs(this.y-t.y),i=Math.abs(this.z-t.z);return s<e&&n<e&&i<e}zero(){return this.x=0,this.y=0,this.z=0,this}rotate(t,e){let s,n,i,o=Math.cos(t),a=Math.sin(t);switch(e){case"X":s=this.x,n=this.y*o-this.z*a,i=this.y*a+this.z*o;break;case"Y":s=this.z*a+this.x*o,n=this.y,i=this.z*o-this.x*a;break;case"Z":s=this.x*o-this.y*a,n=this.x*a+this.y*o,i=this.z}return this.x=s,this.y=n,this.z=i,this}projectOnVector(t){let e=t.dot(this)/t.lengthSq();return this.copy(t).multiplyScalar(e)}projectOnPlane(){let t=new this.constructor;return function(e){return t.copy(this).normalised().projectOnVector(e.normalised()),this.min(t).normalize()}}applyM3(t){let e=this.x,s=this.y,n=this.z,i=t.elements;return this.x=i[0]*e+i[1]*s+i[2]*n,this.y=i[3]*e+i[4]*s+i[5]*n,this.z=i[6]*e+i[7]*s+i[8]*n,this.normalize()}applyMatrix3(t){let e=this.x,s=this.y,n=this.z,i=t.elements;return this.x=i[0]*e+i[3]*s+i[6]*n,this.y=i[1]*e+i[4]*s+i[7]*n,this.z=i[2]*e+i[5]*s+i[8]*n,this}applyQuaternion(t){let e=this.x,s=this.y,n=this.z,i=t.x,o=t.y,a=t.z,h=t.w,r=h*e+o*n-a*s,l=h*s+a*e-i*n,c=h*n+i*s-o*e,d=-i*e-o*s-a*n;return this.x=r*h+d*-i+l*-a-c*-o,this.y=l*h+d*-o+c*-i-r*-a,this.z=c*h+d*-a+r*-o-l*-i,this}sign(t,e){return this.cross(t).dot(e)>=0?1:-1}angleTo(t){let e=this.dot(t)/Math.sqrt(this.lengthSq()*t.lengthSq());return e<=-1?Math.PI:e>=1?0:Math.acos(e)}getSignedAngle(t,e){let s=this.angleTo(t);return 1===this.sign(t,e)?s:-s}constrainedUV(t,e,s,n,i){let o=t.getSignedAngle(this,e);return o>i&&this.copy(s.rotateAboutAxis(t,i,e)),o<n&&this.copy(s.rotateAboutAxis(t,n,e)),this}limitAngle(t,e,s){if(t.angleTo(this)>s){let n=t.normalised().cross(this).normalize();this.copy(e.rotateAboutAxis(t,s,n))}return this}}class o{constructor(t,e,s,n,i,a,h,r,l){o.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],arguments.length>0&&console.error("M3: the constructor no longer reads arguments. use .set() instead."),void 0!==t&&this.set(t,e,s,n,i,a,h,r,l)}get XBasis(){return new i(this.elements[0],this.elements[1],this.elements[2])}set XBasis(t){this.elements[0]=t.x,this.elements[1]=t.y,this.elements[2]=t.z}get YBasis(){return new i(this.elements[3],this.elements[4],this.elements[5])}set YBasis(t){this.elements[3]=t.x,this.elements[4]=t.y,this.elements[5]=t.z}get ZBasis(){return new i(this.elements[6],this.elements[7],this.elements[8])}set ZBasis(t){this.elements[6]=t.x,this.elements[7]=t.y,this.elements[8]=t.z}set(t,e,s,n,i,o,a,h,r){let l=this.elements;return l[0]=t,l[1]=n,l[2]=a,l[3]=e,l[4]=i,l[5]=h,l[6]=s,l[7]=o,l[8]=r,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}setV3(t,e,s){const n=this.elements;return n[0]=t.x,n[3]=t.y,n[6]=t.z,n[1]=e.x,n[4]=e.y,n[7]=e.z,n[2]=s.x,n[5]=s.y,n[8]=s.z,this}transpose(){let t,e=this.elements;return t=e[1],e[1]=e[3],e[3]=t,t=e[2],e[2]=e[6],e[6]=t,t=e[5],e[5]=e[7],e[7]=t,this}createRotationMatrix(t){let e=t,s=new i(1,0,0),n=new i(0,1,0);return Math.abs(t.y)>.9999||s.copy(e).cross(n).normalize(),n.copy(s).cross(e).normalize(),this.setV3(s,n,e)}rotateDegs(t,e){return this.rotateRads(t,e*s.toRad)}rotateRads(t,e){const s=new this.constructor;let n=Math.sin(e),i=Math.cos(e),o=1-i,a=t.x*t.y,h=t.y*t.z,r=t.x*t.z,l=t.x*n,c=t.y*n,d=t.z*n,u=t.x*t.x*o+i,m=a*o+d,g=r*o-c,b=a*o-d,C=t.y*t.y*o+i,y=h*o+l,p=r*o+c,x=h*o-l,B=t.z*t.z*o+i,f=this.elements,M=f[0]*u+f[3]*m+f[6]*g,T=f[1]*u+f[4]*m+f[7]*g,L=f[2]*u+f[5]*m+f[8]*g,w=f[0]*b+f[3]*C+f[6]*y,v=f[1]*b+f[4]*C+f[7]*y,V=f[2]*b+f[5]*C+f[8]*y,E=E[6]=f[0]*p+f[3]*x+f[6]*B;return E[7]=f[1]*p+f[4]*x+f[7]*B,E[8]=f[2]*p+f[5]*x+f[8]*B,E[0]=M,E[1]=T,E[2]=L,E[3]=w,E[4]=v,E[5]=V,s}rotateAboutAxis(t,e,s){let n=Math.sin(e),i=Math.cos(e),o=1-i,a=s.x*s.y*o,h=s.x*s.z*o,r=s.y*s.z*o,l=this.elements;l[0]=s.x*s.x*o+i,l[3]=a+s.z*n,l[6]=h-s.y*n,l[1]=a-s.z*n,l[4]=s.y*s.y*o+i,l[7]=r+s.x*n,l[2]=h+s.y*n,l[5]=r-s.x*n,l[8]=s.z*s.z*o+i;return t.clone().applyM3(this)}determinant(){const t=this.elements,e=t[0],s=t[1],n=t[2],i=t[3],o=t[4],a=t[5],h=t[6],r=t[7],l=t[8];return e*o*l-e*a*r-s*i*l+s*a*h+n*i*r-n*o*h}invert(){const t=this.elements,e=t[0],s=t[1],n=t[2],i=t[3],o=t[4],a=t[5],h=t[6],r=t[7],l=t[8],c=l*o-a*r,d=a*h-l*i,u=r*i-o*h,m=e*c+s*d+n*u;if(0===m)return this.set(0,0,0,0,0,0,0,0,0);const g=1/m;return t[0]=c*g,t[1]=(n*r-l*s)*g,t[2]=(a*s-n*o)*g,t[3]=d*g,t[4]=(l*e-n*h)*g,t[5]=(n*i-a*e)*g,t[6]=u*g,t[7]=(s*h-r*e)*g,t[8]=(o*e-s*i)*g,this}multiplyMatrices(t,e){const s=t.elements,n=e.elements,i=this.elements,o=s[0],a=s[3],h=s[6],r=s[1],l=s[4],c=s[7],d=s[2],u=s[5],m=s[8],g=n[0],b=n[3],C=n[6],y=n[1],p=n[4],x=n[7],B=n[2],f=n[5],M=n[8];return i[0]=o*g+a*y+h*B,i[3]=o*b+a*p+h*f,i[6]=o*C+a*x+h*M,i[1]=r*g+l*y+c*B,i[4]=r*b+l*p+c*f,i[7]=r*C+l*x+c*M,i[2]=d*g+u*y+m*B,i[5]=d*b+u*p+m*f,i[8]=d*C+u*x+m*M,this}premultiply(t){return this.multiplyMatrices(t,this)}multiply(t){return this.multiplyMatrices(this,t)}setFromMatrix4(t){const e=t.elements;return this.set(e[0],e[4],e[8],e[1],e[5],e[9],e[2],e[6],e[10]),this}copy(t){const e=this.elements,s=t.elements;return e[0]=s[0],e[1]=s[1],e[2]=s[2],e[3]=s[3],e[4]=s[4],e[5]=s[5],e[6]=s[6],e[7]=s[7],e[8]=s[8],this}fromArray(t,e=0){for(let s=0;s<9;s++)this.elements[s]=t[s+e];return this}toArray(t=[],e=0){const s=this.elements;return t[e]=s[0],t[e+1]=s[1],t[e+2]=s[2],t[e+3]=s[3],t[e+4]=s[4],t[e+5]=s[5],t[e+6]=s[6],t[e+7]=s[7],t[e+8]=s[8],t}clone(){return(new this.constructor).fromArray(this.elements)}isOrthogonal(){const t=this.XBasis.dot(this.YBasis),e=this.XBasis.dot(this.ZBasis),n=this.YBasis.dot(this.ZBasis);return!!(s.nearEquals(t,0,.01)&&s.nearEquals(e,0,.01)&&s.nearEquals(n,0,.01))}}const a=1/0,h=10,r=11,l=12,c=21,d=new i(1,0,0),u=new i(0,1,0),m=new i(0,0,1),g=new i(-1,0,0),b=new i(0,-1,0),C=new i(0,0,-1),y=new n(0,1),p=new n(0,-1),x=new n(-1,0),B=new n(1,0);class f{constructor(){this.isJoint3D=!0,this.rotor=s.PI,this.min=-s.PI,this.max=s.PI,this.freeHinge=!0,this.rotationAxisUV=new i,this.referenceAxisUV=new i,this.type=h}clone(){let t=new this.constructor;return t.type=this.type,t.rotor=this.rotor,t.max=this.max,t.min=this.min,t.freeHinge=this.freeHinge,t.rotationAxisUV.copy(this.rotationAxisUV),t.referenceAxisUV.copy(this.referenceAxisUV),t}testAngle(){this.max===s.PI&&this.min===-s.PI?this.freeHinge=!0:this.freeHinge=!1}validateAngle(t){return t=(t=t<0?0:t)>180?180:t}setAsBallJoint(t){this.rotor=this.validateAngle(t)*s.toRad,this.type=h}setHinge(t,e,n,i,o){this.type=t,n<0&&(n*=-1),this.min=-this.validateAngle(n)*s.toRad,this.max=this.validateAngle(i)*s.toRad,this.testAngle(),this.rotationAxisUV.copy(e).normalize(),this.referenceAxisUV.copy(o).normalize()}getHingeReferenceAxis(){return this.referenceAxisUV}getHingeRotationAxis(){return this.rotationAxisUV}setBallJointConstraintDegs(t){this.rotor=this.validateAngle(t)*s.toRad}setHingeClockwise(t){t<0&&(t*=-1),this.min=-this.validateAngle(t)*s.toRad,this.testAngle()}setHingeAnticlockwise(t){this.max=this.validateAngle(t)*s.toRad,this.testAngle()}}class M{constructor(t,e,s,n,o){this.isBone3D=!0,this.joint=new f,this.start=new i,this.end=new i,this.dir=new i,this.boneConnectionPoint=c,this.length=0,this.color=o||16777215,this.name="",this.init(t,e,s,n),this.dir=this.getDirection()}init(t,e,s,n){this.setStartLocation(t),e?(this.setEndLocation(e),this.length=this.getLength()):(this.setLength(n),this.setEndLocation(this.start.plus(s.normalised().multiplyScalar(n))))}clone(){let t=new this.constructor(this.start,this.end);return t.joint=this.joint.clone(),t}setColor(t){this.color=t}setBoneConnectionPoint(t){this.boneConnectionPoint=t}setHingeClockwise(t){this.joint.setHingeClockwise(t)}setHingeAnticlockwise(t){this.joint.setHingeAnticlockwise(t)}setBallJointConstraintDegs(t){this.joint.setBallJointConstraintDegs(t)}setStartLocation(t){this.start.copy(t)}setEndLocation(t){this.end.copy(t)}getDirection(){return this.end.clone().min(this.start).normalize()}setLength(t){t>0&&(this.length=t)}setJoint(t){this.joint=t}getBoneConnectionPoint(){return this.boneConnectionPoint}getDirectionUV(){return this.end.minus(this.start).normalize()}getLength(){return this.start.distanceTo(this.end)}}class T{constructor(t,e,n){this.isJoint2D=!0,this.coordinateSystem=n||r,t<0&&(t*=-1),this.min=void 0!==t?-t*s.toRad:-s.PI,this.max=void 0!==e?e*s.toRad:s.PI}clone(){let t=new this.constructor;return t.coordinateSystem=this.coordinateSystem,t.max=this.max,t.min=this.min,t}validateAngle(t){return t=(t=t<0?0:t)>180?180:t}set(t){this.max=t.max,this.min=t.min,this.coordinateSystem=t.coordinateSystem}setClockwiseConstraintDegs(t){t<0&&(t*=-1),this.min=-this.validateAngle(t)*s.toRad}setAnticlockwiseConstraintDegs(t){this.max=this.validateAngle(t)*s.toRad}setConstraintCoordinateSystem(t){this.coordinateSystem=t}getConstraintCoordinateSystem(){return this.coordinateSystem}}class L{constructor(t,e,s,i,o,a,h){this.isBone2D=!0,this.start=new n,this.end=new n,this.length=i||0,this.joint=new T(o,a),this.globalConstraintUV=new n(1,0),this.boneConnectionPoint=c,this.color=h||null,this.name="",this.setStartLocation(t),e?(this.setEndLocation(e),0===this.length&&(this.length=this.getLength())):s&&this.setEndLocation(this.start.plus(s.normalised().multiplyScalar(this.length)))}clone(){let t=new L(this.start,this.end);return t.length=this.length,t.globalConstraintUV=this.globalConstraintUV,t.boneConnectionPoint=this.boneConnectionPoint,t.joint=this.joint.clone(),t.color=this.color,t.name=this.name,t}setName(t){this.name=t}setColor(t){this.color=t}setBoneConnectionPoint(t){this.boneConnectionPoint=t}setStartLocation(t){this.start.copy(t)}setEndLocation(t){this.end.copy(t)}setLengt(t){t>0&&(this.length=t)}setGlobalConstraintUV(t){this.globalConstraintUV=t}setJoint(t){this.joint=t}setClockwiseConstraintDegs(t){this.joint.setClockwiseConstraintDegs(t)}setAnticlockwiseConstraintDegs(t){this.joint.setAnticlockwiseConstraintDegs(t)}setJointConstraintCoordinateSystem(t){this.joint.setConstraintCoordinateSystem(t)}getGlobalConstraintUV(){return this.globalConstraintUV}getBoneConnectionPoint(){return this.boneConnectionPoint}getDirectionUV(){return this.end.minus(this.start).normalize()}getLength(){return this.start.distanceTo(this.end)}}class w{constructor(t){this.isChain2D=!0,this.tmpTarget=new n,this.bones=[],this.name="",this.solveDistanceThreshold=1,this.minIterationChange=.01,this.maxIteration=15,this.precision=.001,this.chainLength=0,this.numBones=0,this.baseLocation=new n,this.fixedBaseMode=!0,this.baseboneConstraintType=1,this.baseboneConstraintUV=new n,this.baseboneRelativeConstraintUV=new n,this.lastTargetLocation=new n(a,a),this.lastBaseLocation=new n(a,a),this.boneConnectionPoint=c,this.currentSolveDistance=a,this.connectedChainNumber=-1,this.connectedBoneNumber=-1,this.color=t||16777215,this.embeddedTarget=new n,this.useEmbeddedTarget=!1}clone(){let t=new this.constructor;return t.solveDistanceThreshold=this.solveDistanceThreshold,t.minIterationChange=this.minIterationChange,t.maxIteration=this.maxIteration,t.precision=this.precision,t.bones=this.cloneBones(),t.baseLocation.copy(this.baseLocation),t.lastTargetLocation.copy(this.lastTargetLocation),t.lastBaseLocation.copy(this.lastBaseLocation),1!==this.baseboneConstraintType&&(t.baseboneConstraintUV.copy(this.baseboneConstraintUV),t.baseboneRelativeConstraintUV.copy(this.baseboneRelativeConstraintUV)),t.fixedBaseMode=this.fixedBaseMode,t.chainLength=this.chainLength,t.numBones=this.numBones,t.currentSolveDistance=this.currentSolveDistance,t.boneConnectionPoint=this.boneConnectionPoint,t.connectedChainNumber=this.connectedChainNumber,t.connectedBoneNumber=this.connectedBoneNumber,t.baseboneConstraintType=this.baseboneConstraintType,t.color=this.color,t.embeddedTarget=this.embeddedTarget.clone(),t.useEmbeddedTarget=this.useEmbeddedTarget,t}clear(){let t=this.numBones;for(;t--;)this.removeBone(t)}addBone(t){null===t.color&&t.setColor(this.color),this.bones.push(t),0===this.numBones&&(this.baseLocation.copy(t.start),this.baseboneConstraintUV.copy(t.getDirectionUV())),this.numBones++,this.updateChainLength()}removeBone(t){t<this.numBones&&(this.bones.splice(t,1),this.numBones--,this.updateChainLength())}addConsecutiveBone(t,n,i,o,a){if(0!==this.numBones){if(t.isBone2D){let e=t,n=e.getDirectionUV();s.validateDirectionUV(n);let i=e.length;s.validateLength(i);let o=this.bones[this.numBones-1].end;e.setStartLocation(o),e.setEndLocation(o.plus(n.multiplyScalar(i))),this.addBone(e)}else if(t.isVector2){a=a||this.color,s.validateDirectionUV(t),s.validateLength(n);let e=this.bones[this.numBones-1].end;this.addBone(new L(e,null,t.normalised(),n,i,o,a))}}else e("Chain is empty ! need first bone")}getBoneConnectionPoint(){return this.boneConnectionPoint}getConnectedBoneNumber(){return this.connectedBoneNumber}getConnectedChainNumber(){return this.connectedChainNumber}getEmbeddedTarget(){return this.embeddedTarget}getBaseboneConstraintType(){return this.baseboneConstraintType}getBaseboneConstraintUV(){if(1!==this.baseboneConstraintType)return this.baseboneConstraintUV}getBaseLocation(){return this.bones[0].start}getEffectorLocation(){return this.bones[this.numBones-1].end}getLastTargetLocation(){return this.lastTargetLocation}getLiveChainLength(){let t=0,e=this.numBones;for(;e--;)t+=this.bones[e].getLength();return t}setColor(t){this.color=t;let e=this.numBones;for(;e--;)this.bones[e].setColor(this.color)}setBaseboneRelativeConstraintUV(t){this.baseboneRelativeConstraintUV=t}setConnectedBoneNumber(t){this.connectedBoneNumber=t}setConnectedChainNumber(t){this.connectedChainNumber=t}setBoneConnectionPoint(t){this.boneConnectionPoint=t}setBaseboneConstraintUV(t){s.validateDirectionUV(t),this.baseboneConstraintUV.copy(t.normalised())}setBaseLocation(t){this.baseLocation.copy(t)}setBaseboneConstraintType(t){this.baseboneConstraintType=t}setFixedBaseMode(t){(t||-1===this.connectedChainNumber)&&(6!==this.baseboneConstraintType||t)&&(this.fixedBaseMode=t)}setMaxIterationAttempts(t){t<1||(this.maxIteration=t)}setMinIterationChange(t){t<0||(this.minIterationChange=t)}setSolveDistanceThreshold(t){t<0||(this.solveDistanceThreshold=t)}solveForEmbeddedTarget(){if(this.useEmbeddedTarget)return this.solveForTarget(this.embeddedTarget)}resetTarget(){this.lastBaseLocation=new n(a,a),this.currentSolveDistance=a}solveForTarget(t){this.tmpTarget.set(t.x,t.y);let e,s=this.precision,n=this.lastBaseLocation.approximatelyEquals(this.baseLocation,s);if(this.lastTargetLocation.approximatelyEquals(this.tmpTarget,s)&&n)return this.currentSolveDistance;let i=null;n?(e=this.bones[this.numBones-1].end.distanceTo(this.tmpTarget),i=this.cloneBones()):e=a;let o,h=[],r=a,l=a,c=this.maxIteration;for(;c--;){if(o=this.solveIK(this.tmpTarget),o<r){if(r=o,h=this.cloneBones(),o<=this.solveDistanceThreshold)break}else if(Math.abs(o-l)<this.minIterationChange)break;l=o}return r<e?(this.currentSolveDistance=r,this.bones=h):(this.currentSolveDistance=e,this.bones=i),this.lastBaseLocation.copy(this.baseLocation),this.lastTargetLocation.copy(this.tmpTarget),this.currentSolveDistance}solveIK(t){if(0===this.numBones)return;let e,s,n,i,o,a,h,l=this.numBones;for(;l--;)e=this.bones[l],s=e.length,l!==this.numBones-1?(n=this.bones[l+1],a=e.getDirectionUV().negate(),h=e.joint.coordinateSystem===r?n.getDirectionUV().negate():e.getGlobalConstraintUV().negated(),a.constrainedUV(h,n.joint.min,n.joint.max),i=e.end.plus(a.multiplyScalar(s)),e.setStartLocation(i),l>0&&this.bones[l-1].setEndLocation(i)):(e.setEndLocation(t),a=e.getDirectionUV().negate(),l>0?(h=e.joint.coordinateSystem===r?this.bones[l-1].getDirectionUV().negate():e.getGlobalConstraintUV().negated(),a.constrainedUV(h,e.joint.min,e.joint.max)):e.joint.coordinateSystem!==r&&(h=e.getGlobalConstraintUV().negated(),a.constrainedUV(h,e.joint.min,e.joint.max)),i=e.end.plus(a.multiplyScalar(s)),e.setStartLocation(i),l>0&&this.bones[l-1].setEndLocation(i));for(l=0;l<this.numBones;l++)e=this.bones[l],s=e.length,0!==l?(a=e.getDirectionUV(),h=e.joint.coordinateSystem===r?this.bones[l-1].getDirectionUV():e.getGlobalConstraintUV(),a.constrainedUV(h,e.joint.min,e.joint.max),o=e.start.plus(a.multiplyScalar(s)),e.setEndLocation(o),l<this.numBones-1&&this.bones[l+1].setStartLocation(o)):(this.fixedBaseMode?e.setStartLocation(this.baseLocation):(i=e.end.minus(e.getDirectionUV().multiplyScalar(s)),e.setStartLocation(i)),a=e.getDirectionUV(),1===this.baseboneConstraintType?(o=e.start.plus(a.multiplyScalar(s)),e.setEndLocation(o),this.numBones>1&&this.bones[1].setStartLocation(o)):(h=8===this.baseboneConstraintType?this.baseboneRelativeConstraintUV:this.baseboneConstraintUV,a.constrainedUV(h,e.joint.min,e.joint.max),o=e.start.plus(a.multiplyScalar(s)),e.setEndLocation(o),l<this.numBones-1&&this.bones[l+1].setStartLocation(o)));return this.lastTargetLocation.copy(t),this.bones[this.numBones-1].end.distanceTo(t)}updateChainLength(){this.chainLength=0;let t=this.numBones;for(;t--;)this.chainLength+=this.bones[t].length}cloneBones(){let t=[];for(let e=0,s=this.bones.length;e<s;e++)t.push(this.bones[e].clone());return t}}class v{constructor(t,e){this.THREE=e,this.isStructure2D=!0,this.fixedBaseMode=!0,this.chains=[],this.meshChains=[],this.angleChains=[],this.targets=[],this.numChains=0,this.scene=t||null,this.isWithMesh=!1}update(){let t,e,n,i,o,a,h,r;new this.THREE.Vector3;for(let l=0;l<this.numChains;l++){if(t=this.chains[l],i=this.targets[l]||null,o=t.getConnectedChainNumber(),a=t.getBaseboneConstraintType(),-1!==o&&6!==a){let e=this.chains[o].bones[t.getConnectedBoneNumber()];t.setBaseLocation(20===t.getBoneConnectionPoint()?e.start:e.end);let s=e.getDirectionUV();if(7===a)t.setBaseboneConstraintUV(s);else if(8===a){r=y.getSignedAngle(s);let e=t.getBaseboneConstraintUV().clone().rotate(r);t.setBaseboneRelativeConstraintUV(e)}}if(t.useEmbeddedTarget?console.log("embed",t.solveForEmbeddedTarget()):t.solveForTarget(i),this.isWithMesh){e=this.meshChains[l],r=this.angleChains[l];for(let i=0;i<t.numBones;i++)n=t.bones[i],e[i].position.set(n.start.x,n.start.y,0),h=s.unwrapRad(-Math.atan2(n.start.x-n.end.x,n.start.y-n.end.y)),h=s.unwrapRad(-Math.atan2(n.end.x-n.start.x,n.end.y-n.start.y)),e[i].rotation.z=h,r[i]=h*s.toDeg}}}setFixedBaseMode(t){this.fixedBaseMode=t;let e,s=this.numChains;for(;s--;)e=this.chains[s].getConnectedChainNumber(),-1===e&&this.chains[s].setFixedBaseMode(this.fixedBaseMode)}clear(){let t;for(this.clearAllBoneMesh(),t=this.numChains;t--;)this.remove(t);this.chains=[],this.meshChains=[],this.angleChains=[],this.targets=[]}add(t,e,s){this.chains.push(t),this.numChains++,e&&this.targets.push(e),s&&this.addChainMeshs(t)}remove(t){this.chains[t].clear(),this.chains.splice(t,1),this.meshChains.splice(t,1),this.angleChains.splice(t,1),this.targets.splice(t,1),this.numChains--}getNumChains(){return this.numChains}getChain(t){return this.chains[t]}connectChain(t,s,n,i,o,a,h){let r=s,l=n;if(i=i||"end",r>this.numChains)return void e("Chain not existe !");if(l>this.chains[r].numBones)return void e("Bone not existe !");let d=t.clone();d.setBoneConnectionPoint("end"===i?c:20),d.setConnectedChainNumber(r),d.setConnectedBoneNumber(l);let u="end"===i?this.chains[r].bones[l].end:this.chains[r].bones[l].start;d.setBaseLocation(u),d.setFixedBaseMode(!0);for(let t=0;t<d.numBones;t++)d.bones[t].start.add(u),d.bones[t].end.add(u);this.add(d,o,a)}addChainMeshs(t,e){this.isWithMesh=!0;let s=[],n=[],i=t.bones.length;for(let e=0;e<i;e++)s.push(this.addBoneMesh(t.bones[e])),n.push(0);this.meshChains.push(s),this.angleChains.push(n)}addBoneMesh(t){let e=t.length,s=t.color,n=new this.THREE.CylinderGeometry(.5,1,e,4);n.translate(0,.5*e,0);let i=new this.THREE.MeshStandardMaterial({color:s,wireframe:!1,shadowSide:this.THREE.DoubleSide});new this.THREE.MeshBasicMaterial({wireframe:!0});let o=new this.THREE.Mesh(n,i);return o.castShadow=!0,o.receiveShadow=!0,this.scene.add(o),o}clearAllBoneMesh(){if(!this.isWithMesh)return;let t,e,s;for(t=this.meshChains.length;t--;){for(e=this.meshChains[t].length;e--;)s=this.meshChains[t][e],this.scene.remove(s),s.geometry.dispose(),s.material.dispose();this.meshChains[t]=[]}this.meshChains=[]}}t.Bone2D=L,t.Bone3D=M,t.Chain2D=w,t.Chain3D=class{constructor(t){this.isChain3D=!0,this.tmpTarget=new i,this.tmpMtx=new o,this.bones=[],this.name="",this.color=t||16777215,this.solveDistanceThreshold=1,this.minIterationChange=.01,this.maxIteration=20,this.precision=.001,this.chainLength=0,this.numBones=0,this.baseLocation=new i,this.fixedBaseMode=!0,this.baseboneConstraintType=1,this.baseboneConstraintUV=new i,this.baseboneRelativeConstraintUV=new i,this.baseboneRelativeReferenceConstraintUV=new i,this.lastTargetLocation=new i(a,a,a),this.lastBaseLocation=new i(a,a,a),this.currentSolveDistance=a,this.connectedChainNumber=-1,this.connectedBoneNumber=-1,this.boneConnectionPoint=c,this.isFullForward=!1,this.embeddedTarget=new i,this.useEmbeddedTarget=!1}clone(){let t=new this.constructor;return t.solveDistanceThreshold=this.solveDistanceThreshold,t.minIterationChange=this.minIterationChange,t.maxIteration=this.maxIteration,t.precision=this.precision,t.bones=this.cloneBones(),t.baseLocation.copy(this.baseLocation),t.lastTargetLocation.copy(this.lastTargetLocation),t.lastBaseLocation.copy(this.lastBaseLocation),1!==this.baseboneConstraintType&&(t.baseboneConstraintUV.copy(this.baseboneConstraintUV),t.baseboneRelativeConstraintUV.copy(this.baseboneRelativeConstraintUV)),t.fixedBaseMode=this.fixedBaseMode,t.chainLength=this.chainLength,t.numBones=this.numBones,t.currentSolveDistance=this.currentSolveDistance,t.boneConnectionPoint=this.boneConnectionPoint,t.connectedChainNumber=this.connectedChainNumber,t.connectedBoneNumber=this.connectedBoneNumber,t.baseboneConstraintType=this.baseboneConstraintType,t.color=this.color,t.embeddedTarget=this.embeddedTarget.clone(),t.useEmbeddedTarget=this.useEmbeddedTarget,t}clear(){let t=this.numBones;for(;t--;)this.removeBone(t);this.numBones=0}addBone(t){t.setColor(this.color),this.bones.push(t),this.numBones++,1===this.numBones&&(this.baseLocation.copy(t.start),this.baseboneConstraintUV.copy(t.getDirectionUV())),this.updateChainLength()}removeBone(t){t<this.numBones&&(this.bones.splice(t,1),this.numBones--,this.updateChainLength())}addConsecutiveBone(t,e){this.numBones>0&&this.addBone(new M(this.bones[this.numBones-1].end,void 0,t.normalised(),e))}addConsecutiveFreelyRotatingHingedBone(t,e,n,i){this.addConsecutiveHingedBone(t,e,n,i,180,180,s.genPerpendicularVectorQuick(i))}addConsecutiveHingedBone(t,e,s,n,i,o,a){if(0===this.numBones)return;let h=t.normalised(),c=n.normalised(),d=new M(this.bones[this.numBones-1].end,void 0,h,e,this.color);s=s||"global",d.joint.setHinge("global"===s?l:r,c,i,o,a),this.addBone(d)}addConsecutiveRotorConstrainedBone(t,e,s){if(0===this.numBones)return;t=t.normalised();let n=new M(this.bones[this.numBones-1].end,void 0,t,e);n.joint.setAsBallJoint(s),this.addBone(n)}getBoneConnectionPoint(){return this.boneConnectionPoint}getConnectedBoneNumber(){return this.connectedBoneNumber}getConnectedChainNumber(){return this.connectedChainNumber}getBaseboneConstraintType(){return this.baseboneConstraintType}getBaseboneConstraintUV(){if(1!==this.baseboneConstraintType)return this.baseboneConstraintUV}getBaseLocation(){return this.bones[0].start}getEffectorLocation(){return this.bones[this.numBones-1].end}getLastTargetLocation(){return this.lastTargetLocation}getLiveChainLength(){let t=0,e=this.numBones;for(;e--;)t+=this.bones[e].getLength();return t}getBaseboneRelativeReferenceConstraintUV(){return this.baseboneRelativeReferenceConstraintUV}setConnectedBoneNumber(t){this.connectedBoneNumber=t}setConnectedChainNumber(t){this.connectedChainNumber=t}setBoneConnectionPoint(t){this.boneConnectionPoint=t}setColor(t){this.color=t;let e=this.numBones;for(;e--;)this.bones[e].setColor(this.color)}setBaseboneRelativeConstraintUV(t){this.baseboneRelativeConstraintUV=t.normalised()}setBaseboneRelativeReferenceConstraintUV(t){this.baseboneRelativeReferenceConstraintUV=t.normalised()}setBaseboneConstraintUV(t){this.baseboneConstraintUV=t.normalised()}setRotorBaseboneConstraint(t,s,n){0!==this.numBones?s.length()>0?(t=t||"global",this.baseboneConstraintType="global"===t?2:4,this.baseboneConstraintUV=s.normalised(),this.baseboneRelativeConstraintUV.copy(this.baseboneConstraintUV),this.bones[0].joint.setAsBallJoint(n)):e("Constraint axis cannot be zero."):e("Chain must contain a basebone before we can specify the basebone constraint type.")}setHingeBaseboneConstraint(t,n,i,o,a){0!==this.numBones?n.length()<=0?e("Hinge rotation axis cannot be zero."):a.length()<=0?e("Hinge reference axis cannot be zero."):s.perpendicular(n,a)?(t=t||"global",this.baseboneConstraintType="global"===t?3:5,this.baseboneConstraintUV=n.normalised(),this.bones[0].joint.setHinge("global"===t?l:r,n,i,o,a)):e("The hinge reference axis must be in the plane of the hinge rotation axis, that is, they must be perpendicular."):e("Chain must contain a basebone before we can specify the basebone constraint type.")}setFreelyRotatingGlobalHingedBasebone(t){this.setHingeBaseboneConstraint("global",t,180,180,s.genPerpendicularVectorQuick(t))}setGlobalHingedBasebone(t,e,s,n){this.setHingeBaseboneConstraint("global",t,e,s,n)}setFreelyRotatingLocalHingedBasebone(t){this.setHingeBaseboneConstraint("local",t,180,180,s.genPerpendicularVectorQuick(t))}setLocalHingedBasebone(t,e,s,n){this.setHingeBaseboneConstraint("local",t,e,s,n)}setBaseLocation(t){this.baseLocation.copy(t)}setFixedBaseMode(t){(t||-1===this.connectedChainNumber)&&(2!==this.baseboneConstraintType||t)&&(this.fixedBaseMode=t)}setMaxIterationAttempts(t){t<1||(this.maxIteration=t)}setMinIterationChange(t){t<0||(this.minIterationChange=t)}setSolveDistanceThreshold(t){t<0||(this.solveDistanceThreshold=t)}solveForEmbeddedTarget(){if(this.useEmbeddedTarget)return this.solveForTarget(this.embeddedTarget)}resetTarget(){this.lastBaseLocation=new i(a,a,a),this.currentSolveDistance=a}solveForTarget(t){this.tmpTarget.set(t.x,t.y,t.z);let e,s=this.precision,n=this.lastBaseLocation.approximatelyEquals(this.baseLocation,s);if(this.lastTargetLocation.approximatelyEquals(this.tmpTarget,s)&&n)return this.currentSolveDistance;let i=null;n?(e=this.bones[this.numBones-1].end.distanceTo(this.tmpTarget),i=this.cloneBones()):e=a;let o,h=[],r=a,l=a,c=this.maxIteration;for(;c--;){if(o=this.solveIK(this.tmpTarget),o<r){if(r=o,h=this.cloneBones(),o<=this.solveDistanceThreshold)break}else if(Math.abs(o-l)<this.minIterationChange)break;l=o}return r<e?(this.currentSolveDistance=r,this.bones=h):(this.currentSolveDistance=e,this.bones=i),this.lastBaseLocation.copy(this.baseLocation),this.lastTargetLocation.copy(this.tmpTarget),this.currentSolveDistance}solveIK(t){if(0===this.numBones)return;let e,s,n,i,o,a,c,d=this.tmpMtx,u=this.numBones;for(;u--;)if(e=this.bones[u],s=e.length,n=e.joint,i=n.type,u!==this.numBones-1){o=this.bones[u+1];let t=o.getDirectionUV().negate(),c=e.getDirectionUV().negate();switch(i){case h:c.limitAngle(t,d,n.rotor);break;case l:a=n.getHingeRotationAxis(),c.projectOnPlane(a);break;case r:u>0?(d.createRotationMatrix(this.bones[u-1].getDirectionUV()),a=n.getHingeRotationAxis().clone().applyM3(d)):a=this.baseboneRelativeConstraintUV,c.projectOnPlane(a)}let m=e.end.plus(c.multiplyScalar(s));e.setStartLocation(m),u>0&&this.bones[u-1].setEndLocation(m)}else{e.setEndLocation(t);let o=e.getDirectionUV().negated();switch(i){case h:break;case l:a=n.getHingeRotationAxis(),o.projectOnPlane(a);break;case r:d.createRotationMatrix(this.bones[u-1].getDirectionUV()),a=n.getHingeRotationAxis().clone().applyM3(d),o.projectOnPlane(a)}let c=t.plus(o.multiplyScalar(s));e.setStartLocation(c),u>0&&this.bones[u-1].setEndLocation(c)}for(u=0;u<this.numBones;u++)if(e=this.bones[u],s=e.length,n=e.joint,i=n.type,0!==u){let t=e.getDirectionUV(),o=this.bones[u-1].getDirectionUV();switch(i){case h:t.limitAngle(o,d,n.rotor);break;case l:a=n.getHingeRotationAxis(),c=n.getHingeReferenceAxis(),t.projectOnPlane(a),n.freeHinge||t.constrainedUV(c,a,d,n.min,n.max);break;case r:d.createRotationMatrix(o),a=n.getHingeRotationAxis().clone().applyM3(d),c=n.getHingeReferenceAxis().clone().applyM3(d),t.projectOnPlane(a),n.freeHinge||t.constrainedUV(c,a,d,n.min,n.max)}let m=e.start.plus(t.multiplyScalar(s));e.setEndLocation(m),u<this.numBones-1&&this.bones[u+1].setStartLocation(m)}else{this.fixedBaseMode?e.setStartLocation(this.baseLocation):e.setStartLocation(e.end.minus(e.getDirectionUV().multiplyScalar(s)));let t,i,o=e.getDirectionUV();switch(this.baseboneConstraintType){case 1:break;case 2:o.limitAngle(this.baseboneConstraintUV,d,n.rotor);break;case 4:o.limitAngle(this.baseboneRelativeConstraintUV,d,n.rotor);break;case 3:t=n.getHingeRotationAxis(),i=n.getHingeReferenceAxis(),o.projectOnPlane(t),n.freeHinge||o.constrainedUV(i,t,d,n.min,n.max);break;case 5:t=this.baseboneRelativeConstraintUV,i=this.baseboneRelativeReferenceConstraintUV,o.projectOnPlane(t),n.freeHinge||o.constrainedUV(i,t,d,n.min,n.max)}let a=e.start.plus(o.multiplyScalar(s));e.setEndLocation(a),this.numBones>1&&this.bones[1].setStartLocation(a)}return this.lastTargetLocation.copy(t),this.bones[this.numBones-1].end.distanceTo(t)}updateChainLength(){this.chainLength=0;let t=this.numBones;for(;t--;)this.chainLength+=this.bones[t].length}cloneBones(){let t=[];for(let e=0,s=this.bones.length;e<s;e++)t.push(this.bones[e].clone());return t}},t.DOWN=p,t.END=c,t.GLOBAL_ABSOLUTE=6,t.GLOBAL_HINGE=3,t.GLOBAL_ROTOR=2,t.HISolver=class{constructor(t,e){this.THREE=e,this.isHISolver=!0,this.startBones=null,this.endBones=null,this.scene=t.scene,this.target=null,this.goal=null,this.swivelAngle=0,this.iteration=15,this.thresholds={position:.1,rotation:.1},this.solver=new v(this.scene,this.THREE),this.bones=[],this.numBones=0,this.rotation=[],this.initStructure(t)}initStructure(t){this.startBones=t.start,this.endBones=t.end,this.angles=t.angles;let e=this.startBones,s=e.children[0];this.bones.push(e);for(let t=0;t<100;t++){if(this.bones.push(s),s===this.endBones){this.createChain();break}e=s,s=e.children[0]}}createChain(){this.numBones=this.bones.length;let t=new w;t.setFixedBaseMode(!0),t.setBaseboneConstraintType(8),this.fakeBone=new L(new n(0,-1),new n(0,0)),this.target=new this.THREE.Vector3;let e=new this.THREE.Vector3,s=new this.THREE.Vector3,i=new this.THREE.Vector3,o=new n,a=0;for(let h=0;h<this.numBones;h++)h>0&&(this.target.add(this.bones[h].position),a=e.distanceTo(this.bones[h].position),this.bones[h-1].getWorldPosition(s),this.bones[h].getWorldPosition(i),i.sub(s).normalize(),0===i.z?o.set(i.x,i.y):0===i.x&&o.set(i.z,i.y),1===h?t.addBone(new L(new n(0,0),null,o,a,this.angles[h-1][0],this.angles[h-1][1])):t.addConsecutiveBone(o,a,this.angles[h-1][0],this.angles[h-1][1]));this.target.set(10,20,0),this.solver.add(t,this.target,!0)}update(){this.solver.update();let t,e=this.solver.chains[0].bones,n=this.numBones-1;for(let i=0;i<n;i++)t=0===i?s.findAngle(this.fakeBone,e[i]):s.findAngle(e[i-1],e[i]),this.rotation[i]=t*s.toDeg,this.rotation[i]+=t<0?180:-180,this.rotation[i]*=-1;for(let t=0;t<n;t++)this.bones[t].rotation.z=this.rotation[t]*s.toRad}},t.IKSolver=class{constructor(t){this.isIKSolver=!0,this.startBones=null,this.endBones=null,this.target=null,this.goal=null,this.swivelAngle=0,this.iteration=40,this.thresholds={position:.1,rotation:.1},this.solver=null,this.chain=null}},t.J_BALL=h,t.J_GLOBAL=l,t.J_LOCAL=r,t.Joint2D=T,t.Joint3D=f,t.LEFT=x,t.LOCAL_ABSOLUTE=8,t.LOCAL_HINGE=5,t.LOCAL_RELATIVE=7,t.LOCAL_ROTOR=4,t.M3=o,t.MAX_VALUE=a,t.NONE=1,t.PRECISION=.001,t.PRECISION_DEG=.01,t.REVISION="1.4.0",t.RIGHT=B,t.START=20,t.Structure2D=v,t.Structure3D=class{constructor(t,e){this.THREE=e,this.isStructure3D=!0,this.fixedBaseMode=!0,this.chains=[],this.meshChains=[],this.targets=[],this.numChains=0,this.scene=t||null,this.tmpMtx=new o,this.isWithMesh=!1}update(){let t,e,s,n,i,o,a;for(let h=0;h<this.numChains;h++){if(t=this.chains[h],n=this.targets[h],i=t.getConnectedChainNumber(),-1!==i)switch(o=this.chains[i].bones[t.getConnectedBoneNumber()],t.setBaseLocation(20===t.getBoneConnectionPoint()?o.start:o.end),a=t.getBaseboneConstraintType(),a){case 1:case 2:case 3:break;case 4:case 5:this.tmpMtx.createRotationMatrix(o.getDirectionUV());let e=t.getBaseboneConstraintUV().clone().applyM3(this.tmpMtx);t.setBaseboneRelativeConstraintUV(e),5===a&&t.setBaseboneRelativeReferenceConstraintUV(t.bones[0].joint.getHingeReferenceAxis().clone().applyM3(this.tmpMtx))}if(t.useEmbeddedTarget?t.solveForEmbeddedTarget():t.solveForTarget(n),this.isWithMesh){e=this.meshChains[h];for(let n=0;n<t.numBones;n++)s=t.bones[n],e[n].position.copy(s.start),e[n].lookAt(s.end),e[n].userData.extra&&e[n].userData.extra.lookAt(s.start.clone().add(s.dir))}}}clear(){let t;for(this.clearAllBoneMesh(),t=this.numChains;t--;)this.remove(t);this.chains=[],this.meshChains=[],this.targets=[]}add(t,e,s){this.chains.push(t),this.targets.push(e),this.numChains++,s&&this.addChainMeshs(t)}remove(t){this.chains[t].clear(),this.chains.splice(t,1),this.meshChains.splice(t,1),this.targets.splice(t,1),this.numChains--}setFixedBaseMode(t){this.fixedBaseMode=t;let e,s=this.numChains;for(;s--;)e=this.chains[s].getConnectedChainNumber(),-1===e&&this.chains[s].setFixedBaseMode(this.fixedBaseMode)}getNumChains(){return this.numChains}getChain(t){return this.chains[t]}connectChain(t,e,s,n,i,o,a){let h=e,r=s;if(e>this.numChains)return;if(s>this.chains[e].numBones)return;let l=t.clone();void 0!==a&&l.setColor(a),l.setBoneConnectionPoint("end"===n?c:20),l.setConnectedChainNumber(h),l.setConnectedBoneNumber(r);let d="end"===n?this.chains[h].bones[r].end:this.chains[h].bones[r].start;l.setBaseLocation(d),l.setFixedBaseMode(!0);for(let t=0;t<l.numBones;t++)l.bones[t].start.add(d),l.bones[t].end.add(d);this.add(l,i,o)}addChainMeshs(t,e){this.isWithMesh=!0;let s=[],n=t.bones.length;for(let e=0;e<n;e++)s.push(this.addBoneMesh(t.bones[e],e-1,s,t));this.meshChains.push(s)}addBoneMesh(t,e,s,n){let i,o,a,c=2,d=2,u=t.length,m=t.color,g=new this.THREE.CylinderGeometry(1,.5,u,4);g.rotateX(.5*-Math.PI),g.translate(0,0,.5*u);let b,C=new this.THREE.MeshStandardMaterial({color:m,wireframe:!1,shadowSide:this.THREE.DoubleSide}),y=new this.THREE.MeshBasicMaterial({wireframe:!0}),p=null,x=t.joint.type;switch(x){case h:if(y.color.setHex(16737792),t.joint.rotor===Math.PI)break;c=2,d=2,b=new this.THREE.CylinderGeometry(0,d,c,6,1,!0),b.rotateX(.5*-Math.PI),b.translate(0,0,.5*c),p=new this.THREE.Mesh(b,y);break;case l:a=t.joint.getHingeRotationAxis(),i=t.joint.min,o=t.joint.max,d=2,y.color.setHex(16776960),b=new this.THREE.CircleGeometry(d,12,i,-i+o),b.rotateX(.5*-Math.PI),1===a.z&&b.rotateX(.5*-Math.PI),1===a.y&&(b.rotateY(.5*-Math.PI),b.rotateX(.5*-Math.PI)),1===a.x&&b.rotateY(.5*Math.PI),p=new this.THREE.Mesh(b,y);break;case r:a=t.joint.getHingeRotationAxis(),i=t.joint.min,o=t.joint.max,d=2,y.color.setHex(65535),b=new this.THREE.CircleGeometry(d,12,i,-i+o),b.rotateX(.5*-Math.PI),1===a.z&&(b.rotateY(.5*-Math.PI),b.rotateX(.5*Math.PI)),1===a.x&&b.rotateZ(.5*-Math.PI),1===a.y&&(b.rotateX(.5*Math.PI),b.rotateY(.5*Math.PI)),p=new this.THREE.Mesh(b,y)}const B=new this.THREE.AxesHelper(2);let f=new this.THREE.Mesh(g,C);return f.add(B),this.scene.add(f),f.castShadow=!0,f.receiveShadow=!0,-1!==e?null!==p&&(x!==l?(p.position.z=n.bones[e].length,s[e].add(p)):(f.add(p),f.userData.extra=p,f.userData.axe=a)):null!==p&&(f.add(p),f.userData.extra=p,f.userData.axe=new this.THREE.Vector3(0,0,1)),f}clearAllBoneMesh(){if(!this.isWithMesh)return;let t,e,s;for(t=this.meshChains.length;t--;){for(e=this.meshChains[t].length;e--;)s=this.meshChains[t][e],this.scene.remove(s),s.geometry.dispose(),s.material.dispose();this.meshChains[t]=[]}this.meshChains=[]}},t.UP=y,t.V2=n,t.V3=i,t.X_AXE=d,t.X_NEG=g,t.Y_AXE=u,t.Y_NEG=b,t.Z_AXE=m,t.Z_NEG=C,t.math=s,Object.defineProperty(t,"__esModule",{value:!0})}));
